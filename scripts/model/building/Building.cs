using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using CidreDoux.scripts.model.building.crossing_cost;
using CidreDoux.scripts.model.package;
using CidreDoux.scripts.model.tile;
using CidreDoux.scripts.resources.parameters.building;
using Godot;

namespace CidreDoux.scripts.model.building;

/// <summary>
/// Class used to describe a single building in the world.
/// </summary>
public class Building : ICrossingCostComputer, ITurnExecutor
{
    /// <summary>
    /// The type of this building.
    /// </summary>
    public readonly BuildingType Type;

    /// <summary>
    /// The parameters of this building.
    /// </summary>
    public readonly BuildingParameters Parameters;

    /// <summary>
    /// A flag set when the building is destroyed,
    /// i.e. when all its <see cref="ResourceConsumer"/> are destroyed.
    /// </summary>
    public bool IsDestroyed => Consumers.Any(consumer => consumer.IsDestroyed);

    /// <summary>
    /// The <see cref="PackageProducer"/> object managed by this building.
    /// </summary>
    [MaybeNull]
    public readonly PackageProducer PackageProducer;

    /// <summary>
    /// A list of all the <see cref="ResourceConsumer"/> needed by this building.
    /// </summary>
    public readonly List<ResourceConsumer> Consumers;

    /// <summary>
    /// The <see cref="ICrossingCostComputer"/> instance used to compute the crossing cost over this building.
    /// </summary>
    [MaybeNull] private readonly ICrossingCostComputer _crossingCostComputer;

    public Building(BuildingType buildingType)
    {
        // Load the parameters.
        var parametersCollection = ResourceLoader.Load<BuildingParametersCollection>(
            "res://ressources/building_parameters.tres"
        );

        // Find the parameters for the given type.
        Type = buildingType;
        Parameters = parametersCollection.GetParametersForBuildingType(buildingType);

        // Initialize the package producer and the list of consumers.
        PackageProducer = PackageProducer.CreateProducer(Parameters);
        Consumers = new List<ResourceConsumer>(ResourceConsumer.CreateConsumers(Parameters.ConsumerParameters));

        // Initialize the crossing cost.
        _crossingCostComputer = Parameters.CrossingCostParameters switch
        {
            BlockingCrossingCostParameters => new CrossingBlocker(),
            MultiplierCrossingCostParameters parameters => new CrossingCostMultiplier(parameters),
            OverrideCrossingCostParameters parameters => new CrossingCostReplacer(parameters),
            _ => null
        };
    }

    /// <inheritdoc cref="ICrossingCostComputer.ComputeCrossingCost"/>
    public int ComputeCrossingCost(int baseCost)
    {
        return _crossingCostComputer?.ComputeCrossingCost(baseCost) ?? baseCost;
    }

    /// <inheritdoc cref="PackageProducer.ProducePackage"/>
    public Package ProducePackage()
    {
        return IsDestroyed ? null : PackageProducer?.ProducePackage();
    }

    /// <inheritdoc cref="ResourceConsumer.Consume"/>
    public bool Consume(ResourceType resourceType)
    {
        // Try to consume the resource.
        return Consumers.Any(consumer => consumer.Consume(resourceType));
    }

    /// <summary>
    /// Helper used to assign the output path for <see cref="Package"/> generated by this building.
    /// </summary>
    /// <param name="path">The path to assign.</param>
    public void AssignPath(IEnumerable<Tile> path)
    {
        PackageProducer?.AssignPath(path);
    }

    /// <inheritdoc cref="ITurnExecutor.EndTurn"/>
    public void EndTurn()
    {
        // Execute the turn for all the consumers.
        foreach (var consumer in Consumers)
        {
            consumer.EndTurn();
        }

        PackageProducer?.EndTurn();
    }
}
